#!/usr/bin/perl -w

package SNMPTranslate;
	use strict;
	use Data::Dumper;

	my $nametable={
		"sysName"		=> { oid => ".1.3.6.1.2.1.1.5" },
		"zpoolHealth"		=> { oid => ".1.3.6.1.4.1.40045.100.2.1.1.2.5",
						instance => 'string' 
					},
		"sunFmResourceStatus"	=> { oid => ".1.3.6.1.4.1.42.2.195.1.5.1.3",
						value => 'table',
						values => {
							1 => 'other',
							2 => 'ok',
							3 => 'degraded',
							4 => 'unknown',
							5 => 'faulted'
						}
					}
	};

	sub new {
		my ($class) = @_;

		my $self={};
		bless $self, $class;

		$self->reversemap();

		return $self;
	}

	sub reversemap {
		my ($self) = @_;
		foreach my $key ( keys %{$nametable} ) {
			my $value=$nametable->{$key};
			$self->{reversetable}{$value->{oid}}=$key;
		}
	}

	sub name2oid {
		my ($self, $mixname) = @_;

		my ($name, $instance) = ($mixname =~ /^([^.]+)([\d\.]*)$/);
		my $oid=$nametable->{$name}{oid} . $instance;

		#printf("Mixname $mixname Name: $name instance $instance oid $oid\n");

		return $oid;
	}

	sub oid2name {
		my ($self, $oid) = @_;
		my ($full, $name, $instance) = $self->oid2name_all($oid);
		return $full;
	}

	sub instance_decode_string {
		my ($self, $instance) = @_;

		# .100.97.116.97.51 = STRING: "data3"
		my $string="";	
		while($instance =~ s/^\.(\d+)//) {
			$string.=chr($1);
		}
		return $string
	}

	sub value_decode_table {
		my ($self, $value, $def) = @_;

		my $tvalue=$def->{values}{$value};
		if (defined($tvalue)) {
			return { value => $value, string => $tvalue, full => sprintf("%s(%d)", $tvalue, $value) };
		}

		return { value => $value };
	}

	sub value_decode {
		my ($self, $name, $value) = @_;

		my $def=$nametable->{$name};
		if (!defined($def) || !defined($def->{value})) {
			return { value => $value };
		}

		if ($def->{value} eq "table") {
			return $self->value_decode_table($value, $def);
		}

		return { value => $value };
	}

	sub instance_decode {
		my ($self, $name, $instance) = @_;

		my $def=$nametable->{$name};
		if (!defined($def) || !defined($def->{instance})) {
			return $instance;
		}

		if ($def->{instance} eq 'string') {
			return $self->instance_decode_string($instance);
		}

		return $instance;
	}

	sub oid2name_all {
		my ($self, $oid) = @_;

		my $instance="";
		while(length($oid) > 1) {
			my $name=$self->{reversetable}{$oid};
			if (defined($name)) {
				return ( $name . $instance, $name, $self->instance_decode($name, $instance) );
			}

			$oid =~ s/(\.\d+)$//;
			$instance=$1 . $instance;
		}
		die("OID Problem: $oid $instance");
	}

	sub request {
		my $self=shift;

		my @request;

		while(my $name=shift) {
			push @request, $self->name2oid($name);
		}

		return \@request;
	}

	sub response {
		my ($self, $roid) = @_;

		my $r={};
		foreach my $k ( keys %{$roid} ) {
			my $value=$roid->{$k};
			my ($full, $name, $instance)=$self->oid2name_all($k);
			$r->{$full}={ name => $name, instance => $instance, value => $self->value_decode($name, $value) };
		}

		return $r;
	}
		
1;

package Nexenta;
	use Net::SNMP;
	use Data::Dumper;

	sub new {
		my ($class, $snmpsession) = @_;

		my $self = {
			snmp => $snmpsession,
			translate => new SNMPTranslate()
		};

		bless $self, $class;

		$self->_zpool_health_read();
		$self->_sun_fm_read();

		return $self;
	}

	sub _sun_fm_read {
		my ($self) = @_;

		my $oids=$self->{translate}->request("sunFmResourceStatus.1");
		my $result=$self->{snmp}->get_request(-varbindlist => $oids);

		$self->{sunfm}=$self->{translate}->response($result);
	}

	sub sun_fm {
		my ($self) = @_;

		return $self->{sunfm}{"sunFmResourceStatus.1"}{value}{string};
	}

	sub _zpool_health_read {
		my ($self) = @_;

		my $baseoid=$self->{translate}->name2oid("zpoolHealth");
		my $result=$self->{snmp}->get_table(-baseoid => $baseoid);
		$self->{zpoolhealth}=$self->{translate}->response($result);
	}

	sub zpool_health {
		my ($self) = @_;

		my @zpools=map {
				{ name => $_->{instance}, status => $_->{value}{value} }
			} values %{$self->{zpoolhealth}};

		return \@zpools;
	}

1;

package main;

	use strict;
	use open IO => ":encoding(utf-8)";
	use open ':std';
	use Data::Dumper;
	use POSIX;

	use Monitoring::Plugin;
	use Getopt::Long::Descriptive;
	use FindBin qw($Bin $Script);


	sub snmp_new_session {
		my ($opt) = @_;

                my ($session,$error)=Net::SNMP->session(
			Hostname => $opt->host,
			Version	 => 2,
			Timeout  => 2,
			Community => $opt->community
		);

		return $session;
	}



	my ($opt, $usage) = describe_options(
		"$Script %o <some-arg>",
		[ 'host|H=s',		"Nexenta hostname", { required => 1 } ],
		[ 'community|C=s',	"Nexenta hostname", { default => 'public' } ],
		[ 'timeout|t=i',	"Timeout", { default => 15 } ],
		[],
		[ 'help',               "print usage message and exit", { shortcircuit => 1 } ],
	);

	print($usage->text), exit if $opt->help;

	my $np = Monitoring::Plugin->new(
		timeout => $opt->timeout
	);

	my $snmpsession=snmp_new_session($opt);
	my $n=new Nexenta($snmpsession);

	foreach my $zpool ( @{$n->zpool_health()} ) {
		$np->add_message(($zpool->{status} eq 'ONLINE') ? OK : CRITICAL,
			sprintf("Zpool %s %s;", $zpool->{name}, $zpool->{status} ));
	}

	my $fm=$n->sun_fm();
	$np->add_message(($fm eq 'ok') ? OK : CRITICAL,
			sprintf("Sun FaultManager: %s", $fm));

	my ($code, $message) = $np->check_messages();
	$np->plugin_exit( $code, $message );
1;
