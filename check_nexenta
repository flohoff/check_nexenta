#!/usr/bin/perl -w

package SNMPTranslate;
	use strict;
	use Data::Dumper;

	my $nametable={
		"sysName"	=> { oid => ".1.3.6.1.2.1.1.5" },
		"zpoolHealth"	=> { oid => ".1.3.6.1.4.1.40045.100.2.1.1.2.5", instance => 'string' }
	};

	sub new {
		my ($class) = @_;

		my $self={};
		bless $self, $class;

		$self->reversemap();

		return $self;
	}

	sub reversemap {
		my ($self) = @_;
		foreach my $key ( keys %{$nametable} ) {
			my $value=$nametable->{$key};
			$self->{reversetable}{$value->{oid}}=$key;
		}
	}

	sub name2oid {
		my ($self, $mixname) = @_;

		my ($name, $instance) = ($mixname =~ /^([^.]+)([\d\.]*)$/);
		my $oid=$nametable->{$name}{oid} . $instance;

		#printf("Mixname $mixname Name: $name instance $instance oid $oid\n");

		return $oid;
	}

	sub oid2name {
		my ($self, $oid) = @_;
		my ($full, $name, $instance) = $self->oid2name_all($oid);
		return $full;
	}

	sub instance_decode_string {
		my ($self, $instance) = @_;

		# .100.97.116.97.51 = STRING: "data3"
		my $string="";	
		while($instance =~ s/^\.(\d+)//) {
			$string.=chr($1);
		}
		return $string
	}

	sub instance_decode {
		my ($self, $name, $instance) = @_;

		my $def=$nametable->{$name};
		if (!defined($def) || !defined($def->{instance})) {
			return $instance;
		}

		if ($def->{instance} eq 'string') {
			return $self->instance_decode_string($instance);
		}

		return $instance;
	}

	sub oid2name_all {
		my ($self, $oid) = @_;

		my $instance="";
		while(length($oid) > 1) {
			my $name=$self->{reversetable}{$oid};
			if (defined($name)) {
				return ( $name . $instance, $name, $self->instance_decode($name, $instance) );
			}

			$oid =~ s/(\.\d+)$//;
			$instance=$1 . $instance;
		}
		die("OID Problem: $oid $instance");
	}

	sub request {
		my $self=shift;

		my @request;

		while(my $name=shift) {
			printf("Name: $name\n");
			push @request, $self->name2oid($name);
		}

		return \@request;
	}

	sub response {
		my ($self, $roid) = @_;

		my $r={};
		foreach my $k ( keys %{$roid} ) {
			my $value=$roid->{$k};
			my ($full, $name, $instance)=$self->oid2name_all($k);
			$r->{$full}={ name => $name, instance => $instance, value => $value };
		}

		return $r;
	}
		
1;

package Nexenta;
	use Net::SNMP;
	use Data::Dumper;

	sub new {
		my ($class, $snmpsession) = @_;

		my $self = {
			snmp => $snmpsession,
			translate => new SNMPTranslate()
		};

		bless $self, $class;

		$self->_zpool_health_read();

		return $self;
	}

	sub _zpool_health_read {
		my ($self) = @_;

		my $baseoid=$self->{translate}->name2oid("zpoolHealth");
		my $result=$self->{snmp}->get_table(-baseoid => $baseoid);
		$self->{zpoolhealth}=$self->{translate}->response($result);
	}

	sub zpool_health {
		my ($self) = @_;

		my @zpools=values %{$self->{zpoolhealth}};

		return \@zpools;
	}

1;

package main;

	use strict;
	use open IO => ":encoding(utf-8)";
	use open ':std';
	use Data::Dumper;
	use POSIX;

	use Monitoring::Plugin;
	use Getopt::Long::Descriptive;
	use FindBin qw($Bin $Script);


	sub snmp_new_session {
		my ($opt) = @_;

                my ($session,$error)=Net::SNMP->session(
			Hostname => $opt->host,
			Version	 => 2,
			Timeout  => 2,
			Community => $opt->community
		);

		return $session;
	}


	my $np = Monitoring::Plugin->new;

	my ($opt, $usage) = describe_options(
		"$Script %o <some-arg>",
		[ 'host|H=s',		"Nexenta hostname", { required => 1 } ],
		[ 'community|C=s',	"Nexenta hostname", { default => 'public' } ],
		[],
		[ 'help',               "print usage message and exit", { shortcircuit => 1 } ],
	);

	print($usage->text), exit if $opt->help;

	my $snmpsession=snmp_new_session($opt);
	my $n=new Nexenta($snmpsession);

	foreach my $zpool ( @{$n->zpool_health()} ) {
		$np->add_message(($zpool->{value} eq 'ONLINE') ? OK : CRITICAL,
			sprintf("Zpool %s %s;", $zpool->{instance}, $zpool->{value} ));
	}

	my ($code, $message) = $np->check_messages();
	$np->plugin_exit( $code, $message );

1;
